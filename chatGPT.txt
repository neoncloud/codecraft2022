我需要你使用python编写一个parser，输入一个字符串，并返回一个Map对象和一个Agent对象。字符串的格式描述如下：
第一行 2 个整数，表示帧序号（从 1 开始递增）； 当前金钱数 。
第二行 1 个整数，表示场上工作台的数量 K K <=50 。
紧接着 K 行数据，每一行表示一个工作台， 分别由如下所示的数据构成 ，共计 6 个数字：
1.工作台类型： 整数， 范围[1, 9]
2.坐标: 2个浮点x,y
3.剩余生产时间（帧数）: 整数
4.原材料格状态：整数，二进制位表描述，例如48(110000)表示拥有物品4和5。
5.产品格状态：bool

接下来的 4 行数据，每一行表示一个机器人，分别由如下所示的数据构成，每行 10 个数字。
1.所处工作台ID:整数
2.携带物品类型:整数
3.时间价值系数:浮点
4.碰撞价值系数:浮点
5.角速度:浮点
6.线速度:2个浮点
7.朝向:浮点
8.坐标:2个浮点

以下是合法的一帧输入
"""
1144 199346
9
1 43.75 49.25 0 0 1
2 45.75 49.25 0 0 1
3 47.75 49.25 0 0 1
4 43.75 47.25 -1 0 0
5 45.75 47.25 168 0 0
6 47.75 47.25 -1 0 0
7 44.75 45.25 -1 0 0
8 46.75 45.25 -1 0 0
9 46.25 42.25 -1 0 0
5 3 0.9657950401 1 0 0 0 -0.3755806088 47.5760498 47.40252686
-1 0 0 0 0 0 0 -0.006108176429 43.75140762 48.23157501
-1 0 0 0 0 0 0 0 3.25 2.25
-1 0 0 0 0 0 0 0 45.75 1.75
OK
"""
你需要定义Map类和Agent类以包含上述属性。


我需要你使用python编写一个调度器类。这个调度器接收上面描述的Map对象和Agent对象，应该返回一个字典，表示四个机器人应该前往的坐标和应该执行的任务。任务描述如下：
1. 当机器人身处工作台时，可以根据当前工作台的类型执行特定任务，所有可能的任务为"buy","sell"。在执行了"buy"任务后，机器人的携带物品类型（carrying_item属性）将变成对应工作台id；此外，工作台的产品格状态（product_state属性）将变为false。在执行了"sell"任务后，机器人的携带物品类型（carrying_item属性）将变成0；此外，工作台的原材料格状态（material_state属性）将append这个物品。你可以根据Robot类中的workbench_id属性，来确定机器人位于某个工作台。
2. Workbench的id属性决定了工作台能进行的任务。id从1到7的工作台，机器人位于这些工作台可以执行的任务是"buy"，能获得对应的物品。id为1到3的工作台，仅能进行"buy"。id为4的工作台，只能接受携带物品类型为1，2的机器人进行"sell"。id为5的工作台，只能接受携带物品类型为1，3的机器人进行"sell"。id为6的工作台，只能接受携带物品类型为2，3的机器人进行"sell"。id为7的工作台，只能接受携带物品类型为4，5或6的机器人进行"sell"。id为8的工作台，只能进行"sell",只能接受携带物品类型为7的机器人进行"sell"。id为9的工作台，只能进行"sell",能接受携带物品类型为1到7的机器人进行"sell"。
3. 工作台能进行"buy"的前提条件，是产品格状态为True。工作台能进行"sell"的前提条件，是原材料格状态列表中，不存在当前机器人携带物品的类型。
4. 调度器的安排原则是尽可能多地进行"sell"7号物品，其次是进行"sell"4到6号物品，最次是进行"sell"1到3号物品；根据第2点，你可以得知任务之间存在依赖关系，例如要想"buy"7号物品，你需要安排机器人"buy"4，5和6号物品，前往7号工作台进行"sell"，而4，5和6号物品依赖于1，2和3号物品的"buy"。因此，调度器的优先级顺序应该考虑上述依赖关系。
5. 机器人从一个工作台转移到另外一个工作台需要时间。因此在分配任务的时候，需要考虑各个工作台之间的位置关系。你无需遍历workbench，我会提供各个工作台之间的距离，用邻接矩阵表示（numpy.array）；以及一个字典，类似于{1:[5,6,7],2:[7,8,9]},键代表工作台类型id，值是一个列表，代表邻接矩阵对应位置。你只需要根据此查询邻接矩阵就能得到距离。需要注意的是，在地图中，id为同一个的工作台可能不止一个，因此，你需要对查询出的距离进行排序，并选择最小的距离。
6.调度器维护一个queue，


Map类包含三个属性：frame_num，money和workbenches。frame_num是编号，money是可用的货币量，workbenches是一个Workbench类对象列表，每个Workbench对象表示一个工作台。

Workbench 类：

Workbench类表示一个工作台。它包含以下属性：type_id，coord，remaining_time，material_state，product_state和index。type_id表示工作台类型的标识符，coord是工作台的位置坐标，remaining_time是工作台中剩余时间，material_state是一个表示材料状态的列表，例如[4,5]表示此工作台上目前已有4和5号物品，product_state表示工作台上是否有成品，index是工作台的索引。

Robot 类：

Robot类表示一个机器人。它包含以下属性：index，workbench_id，carrying_item，time_value_coeff，collision_value_coeff，angular_velocity，linear_velocity，heading和coord。index表示机器人的唯一标识符，workbench_id表示当前机器人所在的工作台的ID，carrying_item表示机器人当前是否携带物品，time_value_coeff和collision_value_coeff是用于计算物品价值的系数，angular_velocity表示机器人的角速度，linear_velocity是一个长度为2的向量，表示机器人的线速度，heading表示机器人的朝向角度，coord表示机器人的坐标。

对于Robot类，你的调度器仅需要考虑coord属性。

Agent 类：

Agent类表示一组机器人，其中每个机器人都是一个Robot类对象。


调度器先遍历获取4个机器人的状态，对于状态Free==True的机器人安排任务。

为了方便，下面简写为起点：终点的格式，例如 1:4,6 代表workbench.id为1的起点，可以与workbench.id为4或者6的终点进行配对。

1:4,5
2:4,6
3:5,6
4:7:9
5:7,9
6:7,9
7:8,9